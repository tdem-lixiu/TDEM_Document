## 动态库编译指令的学习 ##  

 在动态库编译中，我们常常会遇到这种指令：

```C
!DEC$ Attributes Alias:'函数名' :: 函数 
!DEC$ Attributes C :: 函数
!DEC$ Attributes value :: 变量
```

那么这些指令是什么含义呢，下面将进行详细的讲解。

----

- 1.intel fortran中编译指令主要分为两种，分别是一般编译指令和OMP编译指令；

   一般编译指令是：``!DIR$``,需注意的是，平常我们在编译动态库所使用的指令``!DEC$``是以前的用法，两者是等价的;

    OMP编译指令则是：``!$OMP``。所以可以认为`!DIR$`是一个标识符，提示Intel Fortran这是一个一般编译

- 2.``!DEC$``后面的``Attributes``的意思是：Attributes是属性的意思，它是声明了将对变量或者函数名进行属性声明，所以它的后面要加各种属性的指令；这过程中我们可以将``!DEC$ Attributes``当作一个整体来看待，而后面的属性声明就和定义声明很类似，比如：

```Fortran
    real(kind=8),属性名,属性名,... :: 变量
    !DEC$ Attributes 属性名,属性名,... :: 函数名
```

- 3.所以像`Alias、C、Value`都是一种属性声明，而我们通常使用的属性指令主要还有`Reference、Varying、、Stdcall`，所以接下来将详细介绍这几者的含义。

- 4.``Alias``：在Fortran中，由于不区分大小写，而在c或者c++中是区分的，为了缓解这种矛盾，所以利用`Alias`来给外部链接提供一个规范的名字，所以有：

<center>
``!DEC$ Attributes Allas:'外部调用函数名' :: Fortran函数名``
</center>

- 5.``C``和``Stdcall``：用于管理堆栈一致，一般在调用完程序后需要清理堆栈，但到底是调用方来清理还是被调用方清理呢？而上面两个属性就是用来指定哪一方来清理堆栈的：

    <center> `!DEC$ Attributes C :: 函数名`：由主调用方清除堆栈 </center>
    <center>`!DEC$ Attributes Stdcall :: 函数名`：由被调用方清除堆栈</center>
    <font color="#dd0000"> 注意："C"和"Stdcall"只有在Windows中有区别，而在liunx等其他系统是，两者都是"C"。（具体笔者还没试过）</font>

- 6.``Value``,``Reference``：在Fortran中，虚参的传递都是指针型传递，而在C和C++中却不是这样，所以为了对接二者，需要对一些变量的传递进行特别的声明：

    <center>``!DEC$ Attributes Value :: 变量名``：变量声明为值传递</center>
    <center>``!DEC$ Attributes Reference :: 变量名``：变量声明为指针传递</center>
    <font color="#dd0000"> 经验：在和景旭试验时，当输出参数为值传递时，结果会出错，而只有当为地址传递时，结果才正确。（笔者认为，这是因为如果用值进行虚参传递时，在返回时，实参对应的指针处的值自然是没变的）值得注意的是，你有几个指针型参数，那么就能返回回来几个参数的值，这是因为在C里面，指针型参数相当于输出参数。</font>

    <font color="#dd0000">疑问：那么既然Fortran中全是指针传递，为什么还需要有`Reference`来进行修改呢?在前面中，由于使用了``C``或者``Stdcall``属性，而这些指令会导致子函数变为数值传递(除数组和字符串以外),所以自然需要进行一定修改。</font>

- 7.`Varying`：

----
**字符传递时，中文的传递怎么解决**
笔者在这里提供一个供选择方案：在Fortran声明中使用```character(len=?) :: str```形式，而非使用C中的```character(c_char) :: str```，同时要在再加上一句```!DEC$ ATTRIBUTES REFERENCE :: str```，此时字符串变为了指针传递，在头文件中为``char*``类型，这样子应该是能成功传递的，但是原因笔者尚未找到。
-[x]: 更多属性的学习以及试验

[^1]:正在学习完善中......